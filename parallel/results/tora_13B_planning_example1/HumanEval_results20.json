{"task_id": 20, "completion": "<s> \ndef encrypt(s):\n    '''\n    Create a function encrypt that takes a string as an argument and returns a string encrypted with the alphabet being\n    rotated. The alphabet should be rotated in a manner such that the letters shift down by two multiplied to two places.\n    For example:\n    encrypt(\u2019hi\u2019) returns \u2019lm\u2019\n    encrypt(\u2019asdfghjkl\u2019) returns \u2019ewhjklnop\u2019\n    encrypt(\u2019gf\u2019) returns \u2019kj\u2019\n    encrypt(\u2019et\u2019) returns \u2019ix\u2019\n    Let\u2019s think step by step.\n    1. Create a alphabet, bias two places multiplied by two.\n    2. Loop the input, find the latter bias letter in alphabet.\n    3. Return result.\n    '''\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # The first two elements in the sorted list will be the closest to each other\n    sorted_numbers = sorted(numbers)\n    return sorted_numbers[0], sorted_numbers[1]\n\n\nresult = find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\nprint(result)\nresult = find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\nprint(result)\n```\n```output\n(1.0, 2.0)\n```\nThe two numbers that are closest to each other in the list are $\\boxed{1.0}$ and $\\boxed{2.0}$.</s>"}