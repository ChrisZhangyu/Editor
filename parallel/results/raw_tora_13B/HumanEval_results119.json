{"task_id": 119, "completion": "<s> \ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # The idea is to use a stack to keep track of the opening parentheses. When we see an opening\n    # parenthesis, we push it onto the stack. When we see a closing parenthesis, we pop it from\n    # the stack. If at any point the stack is empty and we still have more closing parentheses\n    # left, then the string is not balanced.\n    stack = []\n    for paren in lst:\n        if paren == '(':\n            stack.append(paren)\n        elif paren == ')':\n            if not stack:\n                return 'No'\n            else:\n                stack.pop()\n    return 'Yes' if not stack else 'No'\n\n\n\nresult = match_parens(['()', '()'])\nprint(result)\nresult = match_parens(['()', ')(']\nprint(result)\nresult = match_parens([')', ')'])\nprint(result)\n</s>"}